# â¾¯è¯•å¸¸è€ƒç®—æ³•æ¨¡æ¿ Cheat Sheet V4.1

ç‰ˆæƒå½’å±ï¼šè¿ˆå¾®ï¼ˆè‹å·ï¼‰ä¿¡æ¯ç§‘æŠ€æœ‰é™å…¬å¸

<br>

## ç›®å½• Menu

- [äºŒåˆ†æ³• Binary Search](#äºŒåˆ†æ³•-binary-search)
  - [ä½¿ç”¨æ¡ä»¶](#ä½¿ç”¨æ¡ä»¶)
  - [å¤æ‚åº¦](#å¤æ‚åº¦)
  - [é¢†æ‰£ä¾‹é¢˜](#é¢†æ‰£ä¾‹é¢˜)
  - [ä»£ç æ¨¡ç‰ˆ](#ä»£ç æ¨¡ç‰ˆ)
- [åŒæŒ‡é’ˆ Two Pointers](#åŒæŒ‡é’ˆ-two-pointers)
- [æ’åºç®—æ³• Sorting](#æ’åºç®—æ³•-sorting)
- [â¼†å‰æ ‘åˆ†æ²» Binary Tree Divide & Conquer](#â¼†å‰æ ‘åˆ†æ²»-binary-tree-divide-conquer)
- [â¼†å‰æœç´¢æ ‘â¾®é€’å½’ BST Iteratorp](#â¼†å‰æœç´¢æ ‘â¾®é€’å½’-bst-iterator)
- [å®½åº¦ä¼˜å…ˆæœç´¢ BFS](#å®½åº¦ä¼˜å…ˆæœç´¢-bfs)
- [æ·±åº¦ä¼˜å…ˆæœç´¢ DFS](#æ·±åº¦ä¼˜å…ˆæœç´¢-dfs)
- [åŠ¨æ€è§„åˆ’ Dynamic Programming](#åŠ¨æ€è§„åˆ’-dynamic-programming)
- [å † Heap](#å †-heap)
- [å¹¶æŸ¥é›† Union Find](#å¹¶æŸ¥é›†-union-find)
- [å­—å…¸æ ‘ Trie](#å­—å…¸æ ‘-trie)


## äºŒåˆ†æ³• Binary Search

### ä½¿ç”¨æ¡ä»¶

1. æ’åºæ•°ç»„ (30-40%æ˜¯â¼†åˆ†)
2. å½“â¾¯è¯•å®˜è¦æ±‚ä½ æ‰¾â¼€ä¸ªâ½ O(n) æ›´â¼©çš„æ—¶é—´å¤æ‚åº¦ç®—æ³•çš„æ—¶å€™(99%)
3. æ‰¾åˆ°æ•°ç»„ä¸­çš„â¼€ä¸ªåˆ†å‰²ä½ç½®ï¼Œä½¿å¾—å·¦åŠéƒ¨åˆ†æ»¡â¾œæŸä¸ªæ¡ä»¶ï¼Œå³åŠéƒ¨åˆ†ä¸æ»¡â¾œ(100%)
4. æ‰¾åˆ°â¼€ä¸ªæœ€â¼¤/æœ€â¼©çš„å€¼ä½¿å¾—æŸä¸ªæ¡ä»¶è¢«æ»¡â¾œ(90%)

### å¤æ‚åº¦
- æ—¶é—´å¤æ‚åº¦ï¼šO(logn)
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)

### é¢†æ‰£ä¾‹é¢˜
- LintCode 14. â¼†åˆ†æŸ¥æ‰¾(åœ¨æ’åºçš„æ•°æ®é›†ä¸Šè¿›â¾â¼†åˆ†)
  - https://www.lintcode.com/problem/first-position-of-target/description
- LintCode 460. åœ¨æ’åºæ•°ç»„ä¸­æ‰¾æœ€æ¥è¿‘çš„Kä¸ªæ•° (åœ¨æœªæ’åºçš„æ•°æ®é›†ä¸Šè¿›â¾â¼†åˆ†)
  - https://www.lintcode.com/problem/find-k-closest-elements/description
- LintCode 437. ä¹¦ç±å¤å°(åœ¨ç­”æ¡ˆé›†ä¸Šè¿›â¾â¼†åˆ† )
  - https://www.lintcode.com/problem/copy-books/description

### ä»£ç æ¨¡ç‰ˆ

Java

```java
int binarySearch(int[] nums, int target) {
  // corner case å¤„ç†
  if (nums == null || nums.length == 0) {
    return -1;
  }

  int start = 0, end = nums.length - 1;

  // è¦ç‚¹1: start + 1 < end
  while (start + 1 < end) {
    // è¦ç‚¹2ï¼šstart + (end - start) / 2
    int mid = start + (end - start) / 2;
    // è¦ç‚¹3ï¼š=, <, > åˆ†å¼€è®¨è®ºï¼Œmid ä¸ +1 ä¹Ÿä¸ -1
    if (nums[mid] == target) {
      return mid;
     } else if (nums[mid] < target) {
      start = mid;
     } else {
      end = mid;
     }
   }

   // è¦ç‚¹4: å¾ªç¯ç»“æŸåï¼Œå•ç‹¬å¤„ç†startå’Œend
   if (nums[start] == target) {
    return start;
   }
   if (nums[end] == target) {
    return end;
   }
    return -1;
}
```


Python

```python
def binary_search(self, nums, target):
	# corner case å¤„ç†
	# è¿™â¾¥ç­‰ä»·äº nums is None or len(nums) == 0
	if not nums:
		return -1

	start, end = 0, len(nums) - 1

	# ç”¨ start + 1 < end è€Œä¸æ˜¯ start < end çš„â½¬çš„æ˜¯ä¸ºäº†é¿å…æ­»å¾ªç¯
	# åœ¨ first position of target çš„æƒ…å†µä¸‹ä¸ä¼šå‡ºç°æ­»å¾ªç¯
	# ä½†æ˜¯åœ¨ last position of target çš„æƒ…å†µä¸‹ä¼šå‡ºç°æ­»å¾ªç¯
	# æ ·ä¾‹ï¼šnums=[1ï¼Œ1] target = 1
	# ä¸ºäº†ç»Ÿä¸€æ¨¡æ¿ï¼Œæˆ‘ä»¬å°±éƒ½é‡‡ç”¨ start + 1 < endï¼Œå°±ä¿è¯ä¸ä¼šå‡ºç°æ­»å¾ªç¯
	while start + 1 < end:
		# python æ²¡æœ‰ overflow çš„é—®é¢˜ï¼Œç›´æ¥ // 2 å°±å¯ä»¥äº†
		# javaå’ŒC++ æœ€å¥½å†™æˆ mid = start + (end - start) / 2
		# é˜²æ­¢åœ¨ start = 2^31 - 1, end = 2^31 - 1 çš„æƒ…å†µä¸‹å‡ºç°åŠ æ³• overflow
		mid = (start + end) // 2
		# > , =, < çš„é€»è¾‘å…ˆåˆ†å¼€å†™ï¼Œç„¶ååœ¨çœ‹çœ‹ = çš„æƒ…å†µæ˜¯å¦èƒ½åˆå¹¶åˆ°å…¶ä»–åˆ†æ”¯é‡Œ
		if nums[mid] < target:
			start = mid
		elif nums[mid] == target:
			end = mid
		else:
			end = mid

	# å› ä¸ºä¸Šâ¾¯çš„å¾ªç¯é€€å‡ºæ¡ä»¶æ˜¯ start + 1 < end
	# å› æ­¤è¿™â¾¥å¾ªç¯ç»“æŸçš„æ—¶å€™ï¼Œstart å’Œ end çš„å…³ç³»æ˜¯ç›¸é‚»å…³ç³»ï¼ˆ1å’Œ2ï¼Œ3å’Œ4è¿™ç§ï¼‰
	# å› æ­¤éœ€è¦å†å•ç‹¬åˆ¤æ–­ start å’Œ end è¿™ä¸¤ä¸ªæ•°è°æ˜¯æˆ‘ä»¬è¦çš„ç­”æ¡ˆ
	# å¦‚æœæ˜¯æ‰¾ first position of target å°±å…ˆçœ‹ startï¼Œå¦åˆ™å°±å…ˆçœ‹ end
	if nums[start] == target:
		return start
	if nums[end] == target:
		return end
	return -1
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## åŒæŒ‡é’ˆ Two Pointers
### ä½¿ç”¨æ¡ä»¶

- æ»‘åŠ¨çª—â¼ (90%)
- æ—¶é—´å¤æ‚åº¦è¦æ±‚ O(n) (80%æ˜¯åŒæŒ‡é’ˆ)
- è¦æ±‚åŸåœ°æ“ä½œï¼Œåªå¯ä»¥ä½¿â½¤äº¤æ¢ï¼Œä¸èƒ½ä½¿â½¤é¢å¤–ç©ºé—´ (80%)
- æœ‰â¼¦æ•°ç»„ subarray /â¼¦å­—ç¬¦ä¸² substring çš„å…³é”®è¯ (50%)
- æœ‰å›â½‚ Palindrome å…³é”®è¯(50%)

### å¤æ‚åº¦

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)
  - æ—¶é—´å¤æ‚åº¦ä¸æœ€å†…å±‚å¾ªç¯ä¸»ä½“çš„æ‰§â¾æ¬¡æ•°æœ‰å…³
  - ä¸æœ‰å¤šå°‘é‡å¾ªç¯â½†å…³
- ç©ºé—´å¤æ‚åº¦ï¼šO(1)
  - åªéœ€è¦åˆ†é…ä¸¤ä¸ªæŒ‡é’ˆçš„é¢å¤–å†…å­˜

### é¢†æ‰£ä¾‹é¢˜
- LintCode 1879. ä¸¤æ•°ä¹‹å’ŒVII(åŒå‘åŒæŒ‡é’ˆ)
  - https://www.lintcode.com/problem/two-sum-vii/description
- LintCode1712.å’Œç›¸åŒçš„â¼†å…ƒâ¼¦æ•°ç»„(ç›¸å‘åŒæŒ‡é’ˆ)
  - https://www.lintcode.com/problem/binary-subarrays-with-sum/description
- LintCode627. æœ€â»“å›â½‚ä¸² (èƒŒå‘åŒæŒ‡é’ˆ)
  - https://www.lintcode.com/problem/longest-palindrome/description
- LintCode 64: åˆå¹¶æœ‰åºæ•°ç»„
  - https://www.lintcode.com/problem/merge-sorted-array


### ä»£ç æ¨¡ç‰ˆ

Java
```java
// ç›¸å‘åŒæŒ‡é’ˆ(patition in quicksort)
public void patition(int[] A, int start, int end) {
	if (start >= end) {
		return;
	}
	int left = start, right = end;
	// key point 1: pivot is the value, not the index
	int pivot = A[(start + end) / 2];
	// key point 2: every time you compare left & right, it should be
	// left <= right not left < right
	while (left <= right) {
		while (left <= right && A[left] < pivot) {
			left++;
		}
		while (left <= right && A[right] > pivot) {
			right--;
		}
		if (left <= right) {
			int temp = A[left];
			A[left] = A[right];
			A[right] = temp;
			left++;
			right--;
		}
	}
}

// èƒŒå‘åŒæŒ‡é’ˆ
left = position;
right = position + 1;
while (left >= 0 && right < length) {
	if (å¯ä»¥åœä¸‹æ¥äº†) {
		break;
	}
	left--;
	right++;
}

// åŒå‘åŒæŒ‡é’ˆ
int j = 0;
for (int i = 0; i < n; i++) {
	// ä¸æ»¡â¾œåˆ™å¾ªç¯åˆ°æ»¡â¾œæ­é…ä¸ºâ½Œ
	while (j < n && i åˆ° jä¹‹é—´ä¸æ»¡è¶³æ¡ä»¶) {
		j += 1;
	}
	if (i åˆ° jä¹‹é—´æ»¡è¶³æ¡ä»¶) {
		å¤„ç†iï¼Œjè¿™æ¬¡æ­é…
	}
}

// åˆå¹¶åŒæŒ‡é’ˆ
ArrayList<Integer> merge(ArrayList<Integer> list1, ArrayList<Integer> list2) {
	// éœ€è¦ new ä¸€ä¸ªæ–°çš„ listï¼Œè€Œä¸æ˜¯åœ¨ list1 æˆ–è€… list2 ä¸Šç›´æ¥æ”¹åŠ¨
	ArrayList<Integer> newList = new ArrayList<Integer>();

	int i = 0, j = 0;
	while (i < list1.size() && j < list2.size()) {
		if (list1.get(i) < list2.get(j)) {
			newList.add(list1.get(i));
			i++;
		} else {
			newList.add(list2.get(j));
			j++;
		}
	}

	// åˆå¹¶ä¸Šä¸‹çš„æ•°åˆ° newList é‡Œ
	// æ— éœ€ç”¨ if (i < list1.size())ï¼Œç›´æ¥ while å³å¯
	while (i < list1.size()) {
		newList.add(list1.get(i));
		i++;
	}
	while (j < list2.size()) {
		newList.add(list2.get(j);
		j++;
	}

	return newList;
}
```

Python
```python
# ç›¸å‘åŒæŒ‡é’ˆ(patition in quicksort)
def patition(self, A, start, end):
	if start >= end:
		return
	left, right = start, end
	# key point 1: pivot is the value, not the index
	pivot = A[(start + end) // 2];
	# key point 2: every time you compare left & right, it should be
	# left <= right not left < right
	while left <= right:
		while left <= right and A[left] < pivot:
			left += 1
		while left <= right and A[right] > pivot:
			right -= 1
		if left <= right:
			A[left], A[right] = A[right], A[left]
			left += 1
			right -= 1

	# èƒŒå‘åŒæŒ‡é’ˆ
	left = position
	right = position + 1
	while left >= 0 and right < len(s):
		if left å’Œ right å¯ä»¥åœä¸‹æ¥äº†:
			break
		left -= 1
		right += 1

	# åŒå‘åŒæŒ‡é’ˆ
	j = 0
	for i in range(n):
	# ä¸æ»¡â¾œåˆ™å¾ªç¯åˆ°æ»¡è¶³æ­é…ä¸ºæ­¢
	while j < n and iåˆ°jä¹‹é—´ä¸æ»¡â¾œæ¡ä»¶:
		j += 1
	if iåˆ°jä¹‹é—´æ»¡â¾œæ¡ä»¶:
		å¤„ç†iåˆ°jè¿™æ®µåŒºé—´

	# åˆå¹¶åŒæŒ‡é’ˆ
	def merge(list1, list2):
	new_list = []
	i, j = 0, 0

	# åˆå¹¶çš„è¿‡ç¨‹åªèƒ½æ“ä½œ i, j çš„ç§»åŠ¨ï¼Œä¸è¦å»â½¤ list1.pop(0) ä¹‹ç±»çš„æ“ä½œ
	# å› ä¸º pop(0) æ˜¯ O(n) çš„æ—¶é—´å¤æ‚åº¦
	while i < len(list1) and j < len(list2):
		if list1[i] < list2[j]:
			new_list.append(list1[i])
			i += 1
		else:
			new_list.append(list2[j])
			j += 1

	# åˆå¹¶å‰©ä¸‹çš„æ•°åˆ° new_list é‡Œ
	# ä¸è¦â½¤ new_list.extend(list1[i:]) ä¹‹ç±»çš„æ–¹æ³•
	# å› ä¸º list1[i:] ä¼šäº§ç”Ÿé¢å¤–ç©ºé—´è€—è´¹
	while i < len(list1):
		new_list.append(list1[i])
		i += 1
	while j < len(list2):
		new_list.append(list2[j])
		j += 1

	return new_list
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## æ’åºç®—æ³• Sorting
### ä½¿ç”¨æ¡ä»¶

### å¤æ‚åº¦

- æ—¶é—´å¤æ‚åº¦ï¼š
  - å¿«é€Ÿæ’åº(æœŸæœ›å¤æ‚åº¦) ï¼š O(nlogn)
  - å½’å¹¶æ’åº(æœ€åå¤æ‚åº¦) ï¼š O(nlogn)
- ç©ºé—´å¤æ‚åº¦ï¼š
  - å¿«é€Ÿæ’åº ï¼š O(1)
  - å½’å¹¶æ’åº ï¼š O(n)

### é¢†æ‰£ä¾‹é¢˜
- LintCode 463. æ•´æ•°æ’åº
  - https://www.lintcode.com/problem/sort-integers/description
- LintCode 464. æ•´æ•°æ’åº II
  - https://www.lintcode.com/problem/sort-integers-ii/description

### ä»£ç æ¨¡æ¿

Java
```java
// quick sort
public class Solution {
	/**
	* @param A an integer array
	* @return void
	*/
	public void sortIntegers(int[] A) {
		quickSort(A, 0, A.length - 1);
	}
	
	private void quickSort(int[] A, int start, int end) {
		if (start >= end) {
			return;
		}
		int left = start, right = end;
		// key point 1: pivot is the value, not the index
		int pivot = A[(start + end) / 2];
		// key point 2: every time you compare left & right, it should be
		// left <= right not left < right
		while (left <= right) {
			while (left <= right && A[left] < pivot) {
				left++;
			}
			while (left <= right && A[right] > pivot) {
				right--;
			}
			if (left <= right) {
				int temp = A[left];
				A[left] = A[right];
				A[right] = temp;
				left++;
				right--;
			}
		}
		quickSort(A, start, right);
		quickSort(A, left, end);
	}
}


// merge sort
public class Solution {
	public void sortIntegers(int[] A) {
		if (A == null || A.length == 0) {
			return;
		}
		int[] temp = new int[A.length];
		mergeSort(A, 0, A.length - 1, temp);
	}
	
	private void mergeSort(int[] A, int start, int end, int[] temp) {
		if (start >= end) {
			return;
		}
		// å¤„ç†å·¦åŠåŒºé—´
		mergeSort(A, start, (start + end) / 2, temp);
		// å¤„ç†å³åŠåŒºé—´
		mergeSort(A, (start + end) / 2 + 1, end, temp);
		// åˆå¹¶æ’åºæ•°ç»„
		merge(A, start, end, temp);
	}
	
	private void merge(int[] A, int start, int end, int[] temp) {
		int middle = (start + end) / 2;
		int leftIndex = start;
		int rightIndex = middle + 1;
		int index = start;
		while (leftIndex <= middle && rightIndex <= end) {
			if (A[leftIndex] < A[rightIndex]) {
				temp[index++] = A[leftIndex++];
			} else {
				temp[index++] = A[rightIndex++];
			}
		}
		while (leftIndex <= middle) {
			temp[index++] = A[leftIndex++];
		}
		while (rightIndex <= end) {
			temp[index++] = A[rightIndex++];
		}
		for (int i = start; i <= end; i++) {
			A[i] = temp[i];
		}
	}
}

```


Python

```python
# quick sort
class Solution:
	# @param {int[]} A an integer array
	# @return nothing
	def sortIntegers(self, A):
		# Write your code here
		self.quickSort(A, 0, len(A) - 1)
	
	def quickSort(self, A, start, end):
		if start >= end:
			return
		left, right = start, end
		# key point 1: pivot is the value, not the index
		pivot = A[(start + end) // 2];
		
		# key point 2: every time you compare left & right, it should be
		# left <= right not left < right
		while left <= right:
			while left <= right and A[left] < pivot:
				left += 1
			while left <= right and A[right] > pivot:
				right -= 1
			if left <= right:
				A[left], A[right] = A[right], A[left]
				
				left += 1
				right -= 1
		self.quickSort(A, start, right)
		self.quickSort(A, left, end)


# merge sort
class Solution:
	def sortIntegers(self, A):
		if not A:
			return A
		temp = [0] * len(A)
		self.merge_sort(A, 0, len(A) - 1, temp)
		
	def merge_sort(self, A, start, end, temp):
		if start >= end:
			return
	
		# å¤„ç†å·¦åŠåŒºé—´
		self.merge_sort(A, start, (start + end) // 2, temp)
		# å¤„ç†å³åŠåŒºé—´
		self.merge_sort(A, (start + end) // 2 + 1, end, temp)
		# åˆå¹¶æ’åºæ•°ç»„
		self.merge(A, start, end, temp)
		
	def merge(self, A, start, end, temp):
		middle = (start + end) // 2
		left_index = start
		right_index = middle + 1
		index = start
		
		while left_index <= middle and right_index <= end:
			if A[left_index] < A[right_index]:
				temp[index] = A[left_index]
				index += 1
				left_index += 1
			else:
				temp[index] = A[right_index]
				index += 1
				right_index += 1
		
		while left_index <= middle:
			temp[index] = A[left_index]
			index += 1
			left_index += 1
		while right_index <= end:
			temp[index] = A[right_index]
			index += 1
			right_index += 1
		
		for i in range(start, end + 1):
			A[i] = temp[i]
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## äºŒå‰æ ‘åˆ†æ²» Binary Tree Divide & Conquer

### ä½¿ç”¨æ¡ä»¶

- â¼†å‰æ ‘ç›¸å…³çš„é—®é¢˜ (99%)
- å¯ä»¥â¼€åˆ†ä¸ºâ¼†å»åˆ†åˆ«å¤„ç†ä¹‹åå†åˆå¹¶ç»“æœ (100%)
- æ•°ç»„ç›¸å…³çš„é—®é¢˜ (10%)

### å¤æ‚åº¦
- æ—¶é—´å¤æ‚åº¦$ O(n)$
- ç©ºé—´å¤æ‚åº¦$ O(n) $ (å«é€’å½’è°ƒâ½¤çš„æ ˆç©ºé—´æœ€â¼¤è€—è´¹)

### é¢†æ‰£ä¾‹é¢˜
- LintCode 1534. å°†â¼†å‰æœç´¢æ ‘è½¬æ¢ä¸ºå·²æ’åºçš„åŒå‘é“¾æ¥åˆ—è¡¨
  - https://www.lintcode.com/problem/convert-binary-search-tree-to-sorted-doubly-linked-list/description
- LintCode 94. â¼†å‰æ ‘ä¸­çš„æœ€â¼¤è·¯å¾„å’Œ
  - https://www.lintcode.com/problem/binary-tree-maximum-path-sum/description
- LintCode 95.éªŒè¯â¼†å‰æŸ¥æ‰¾æ ‘
  - https://www.lintcode.com/problem/validate-binary-search-tree/description

### ä»£ç æ¨¡æ¿
Java
```java
public ResultType divideConquer(TreeNode node) {
	// é€’å½’å‡ºâ¼
	// ä¸€èˆ¬å¤„ç† node == null å°±å¤Ÿäº†
	// ä¸€éƒ¨åˆ†æƒ…å†µä¸éœ€è¦å¤„ç† node == leaf
	if (node == null) {
		return ...;
	}
	
	// å¤„ç†å·¦å­æ ‘
	ResultType leftResult = divideConquer(node.left);
	// å¤„ç†å³å­æ ‘
	ResultType rightResult = divideConquer(node.right);
	//åˆå¹¶ç­”æ¡ˆ
	ResultType result = merge leftResult and rightResult
	return result;
}
```

Python

```python
def divide_conquer(root):
	# é€’å½’å‡ºâ¼
	# ä¸€èˆ¬å¤„ç† node == null å°±å¤Ÿäº†
	# ä¸€éƒ¨åˆ†æƒ…å†µä¸éœ€è¦å¤„ç† node == leaf
	if root is None:
		return ...
	# å¤„ç†å·¦å­æ ‘
	left_result = divide_conquer(node.left)
	# å¤„ç†å³å­æ ‘
	right_result = divide_conquer(node.right)
	# åˆå¹¶ç­”æ¡ˆ
	result = merge left_result and right_result to get merged result
	return result
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## äºŒå‰æœç´¢æ ‘â¾®é€’å½’ BST Iterator

### ä½¿ç”¨æ¡ä»¶

- â½¤â¾®é€’å½’çš„â½…å¼ï¼ˆNon-recursion / Iterationï¼‰å®ç°â¼†å‰æ ‘çš„ä¸­åºéå†
- å¸¸â½¤äº BST ä½†ä¸ä»…ä»…å¯ä»¥â½¤äº BST

### å¤æ‚åº¦

- æ—¶é—´å¤æ‚åº¦ O(n)
- ç©ºé—´å¤æ‚åº¦ O(n)

### é¢†æ‰£ä¾‹é¢˜

- LintCode 67. â¼†å‰æ ‘çš„ä¸­åºéå†
  - https://www.lintcode.com/problem/binary-tree-inorder-traversal/description
- LintCode 902. â¼†å‰æœç´¢æ ‘çš„ç¬¬ k â¼¤å…ƒç´ 
  - https://www.lintcode.com/problem/kth-smallest-element-in-a-bst/description

### ä»£ç æ¨¡æ¿

Java

```java
List<TreeNode> inorderTraversal(TreeNode root) {
	List<TreeNode> inorder = new ArrayList<>();
	if (root == null) {
		return inorder;
	}
	
	// åˆ›å»ºä¸€ä¸ª dummy node, å³æŒ‡é’ˆæŒ‡å‘ root
	// æ”¾åˆ° stack é‡Œï¼Œæ­¤æ—¶æ ˆé¡¶ dummy å°±æ˜¯ iterator çš„å½“å‰ä½ç½®
	TreeNode dummy = new TreeNode(0);
	dummy.right = root;
	Stack<TreeNode> stack = new Stack<>();
	stack.push(dummy);

	// æ¯æ¬¡å°† iterator æŒªåˆ°ä¸‹ä¸€ä¸ªç‚¹
	// å°±æ˜¯è°ƒæ•´ stack ä½¿å¾—æ ˆé¡¶æ˜¯ä¸‹ä¸€ä¸ªç‚¹
	while (!stack.isEmpty()) {
		TreeNode node = stack.pop();
		if (node.right != null) {
			node = node.right;
			while (node != null) {
				stack.push(node);
				node = node.left;
			}
		}
		if (!stack.isEmpty()) {
			inorder.add(stack.peek());
		}
	}
	return inorder;
}
```


Python

```python
def inorder_traversal(root):
	if root is None:
		return []

	# åˆ›å»ºâ¼€ä¸ª dummy nodeï¼Œå³æŒ‡é’ˆæŒ‡å‘ root
	# å¹¶æ”¾åˆ° stack â¾¥ï¼Œæ­¤æ—¶ stack çš„æ ˆé¡¶ dummy
	# æ˜¯ iterator çš„å½“å‰ä½ç½®
	dummy = TreeNode(0)
	dummy.right = root
	stack = [dummy]

	inorder = []
	# æ¯æ¬¡å°† iterator æŒªåˆ°ä¸‹â¼€ä¸ªç‚¹
	# ä¹Ÿå°±æ˜¯è°ƒæ•´ stack ä½¿å¾—æ ˆé¡¶åˆ°ä¸‹â¼€ä¸ªç‚¹
	while stack:
		node = stack.pop()
		if node.right:
			node = node.right
			while node:
				stack.append(node)
				node = node.left
		if stack:
			inorder.append(stack[-1])
	return inorder
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## å®½åº¦ä¼˜å…ˆæœç´¢ BFS

### ä½¿ç”¨æ¡ä»¶


- æ‹“æ‰‘æ’åº(100%)
- å‡ºç°è¿é€šå—çš„å…³é”®è¯(100%)
- åˆ†å±‚éå†(100%)
- ç®€å•å›¾æœ€çŸ­è·¯å¾„(100%)
- ç»™å®šâ¼€ä¸ªå˜æ¢è§„åˆ™ï¼Œä»åˆå§‹çŠ¶æ€å˜åˆ°ç»ˆâ½ŒçŠ¶æ€æœ€å°‘â¼æ­¥(100%)


### å¤æ‚åº¦
- æ—¶é—´å¤æ‚åº¦ï¼šO(n + m)
  - n æ˜¯ç‚¹æ•°, m æ˜¯è¾¹æ•°
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)


### é¢†æ‰£ä¾‹é¢˜
- LintCode 974. 01 çŸ©é˜µ(åˆ†å±‚éå†)
  - https://www.lintcode.com/problem/01-matrix/description
- LintCode 431. æ‰¾â½†å‘å›¾çš„è¿é€šå—
  - https://www.lintcode.com/problem/connected-component-in-undirected-graph/description
- LintCode 127. æ‹“æ‰‘æ’åº
  - https://www.lintcode.com/problem/topological-sorting/description

### ä»£ç æ¨¡ç‰ˆ

Java

```java
ReturnType bfs(Node startNode) {
	// BFS å¿…é¡»è¦â½¤é˜Ÿåˆ— queueï¼Œåˆ«â½¤æ ˆ stackï¼
	Queue<Node> queue = new ArrayDeque<>();
	// hashmap æœ‰ä¸¤ä¸ªä½œâ½¤ï¼Œâ¼€ä¸ªæ˜¯è®°å½•â¼€ä¸ªç‚¹æ˜¯å¦è¢«ä¸¢è¿›è¿‡é˜Ÿåˆ—äº†ï¼Œé¿å…é‡å¤è®¿é—®
	// å¦å¤–â¼€ä¸ªæ˜¯è®°å½• startNode åˆ°å…¶ä»–æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
	// å¦‚æœåªæ±‚è¿é€šæ€§çš„è¯ï¼Œå¯ä»¥æ¢æˆ HashSet å°±â¾
	// node åš key çš„æ—¶å€™â½è¾ƒçš„æ˜¯å†…å­˜åœ°å€
	Map<Node, Integer> distance = new HashMap<>();


	// æŠŠèµ·ç‚¹æ”¾è¿›é˜Ÿåˆ—å’Œå“ˆå¸Œè¡¨â¾¥ï¼Œå¦‚æœæœ‰å¤šä¸ªèµ·ç‚¹ï¼Œéƒ½æ”¾è¿›å»
	queue.offer(startNode);
	distance.put(startNode, 0); // or 1 if necessary

	// while é˜Ÿåˆ—ä¸ç©ºï¼Œä¸åœçš„ä»é˜Ÿåˆ—â¾¥æ‹¿å‡ºâ¼€ä¸ªç‚¹ï¼Œæ‹“å±•é‚»å±…èŠ‚ç‚¹æ”¾åˆ°é˜Ÿåˆ—ä¸­
	while (!queue.isEmpty()) {
		Node node = queue.poll();
		// å¦‚æœæœ‰æ˜ç¡®çš„ç»ˆç‚¹å¯ä»¥åœ¨è¿™â¾¥åŠ ç»ˆç‚¹çš„åˆ¤æ–­
		if (node æ˜¯ç»ˆç‚¹) {
			break or return something;
		}
		for (Node neighbor : node.getNeighbors()) {
			if (distance.containsKey(neighbor)) {
				continue;
			}
			queue.offer(neighbor);
			distance.put(neighbor, distance.get(node) + 1);
		}
	}
	// å¦‚æœéœ€è¦è¿”å›æ‰€æœ‰ç‚¹ç¦»èµ·ç‚¹çš„è·ç¦»ï¼Œå°± return hashmap
	return distance;
	// å¦‚æœéœ€è¦è¿”å›æ‰€æœ‰è¿é€šçš„èŠ‚ç‚¹, å°± return HashMap â¾¥çš„æ‰€æœ‰ç‚¹
	return distance.keySet();
	// å¦‚æœéœ€è¦è¿”å›ç¦»ç»ˆç‚¹çš„æœ€çŸ­è·ç¦»
	return distance.get(endNode);
}
```

Python

```python
def bfs(start_node):
	# BFS å¿…é¡»è¦â½¤é˜Ÿåˆ— queueï¼Œåˆ«â½¤æ ˆ stackï¼
	# distance(dict) æœ‰ä¸¤ä¸ªä½œâ½¤ï¼Œâ¼€ä¸ªæ˜¯è®°å½•â¼€ä¸ªç‚¹æ˜¯å¦è¢«ä¸¢è¿›è¿‡é˜Ÿåˆ—äº†ï¼Œé¿å…é‡å¤è®¿é—®
	# å¦å¤–â¼€ä¸ªæ˜¯è®°å½• start_node åˆ°å…¶ä»–æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
	# å¦‚æœåªæ±‚è¿é€šæ€§çš„è¯ï¼Œå¯ä»¥æ¢æˆ set å°±â¾
	# node åš key çš„æ—¶å€™â½è¾ƒçš„æ˜¯å†…å­˜åœ°å€
	queue = collections.deque([start_node])
	distance = {start_node: 0}

	# while é˜Ÿåˆ—ä¸ç©ºï¼Œä¸åœçš„ä»é˜Ÿåˆ—â¾¥æ‹¿å‡ºâ¼€ä¸ªç‚¹ï¼Œæ‹“å±•é‚»å±…èŠ‚ç‚¹æ”¾åˆ°é˜Ÿåˆ—ä¸­
	while queue:
		node = queue.popleft()
		# å¦‚æœæœ‰æ˜ç¡®çš„ç»ˆç‚¹å¯ä»¥åœ¨è¿™â¾¥åŠ ç»ˆç‚¹çš„åˆ¤æ–­
		if node æ˜¯ç»ˆç‚¹:
		break or return something
		for neighbor in node.get_neighbors():
			if neighor in distnace:
				continue
			queue.append(neighbor)
			distance[neighbor] = distance[node] + 1

	# å¦‚æœéœ€è¦è¿”å›æ‰€æœ‰ç‚¹ç¦»èµ·ç‚¹çš„è·ç¦»ï¼Œå°± return hashmap
	return distance
	# å¦‚æœéœ€è¦è¿”å›æ‰€æœ‰è¿é€šçš„èŠ‚ç‚¹, å°± return HashMap â¾¥çš„æ‰€æœ‰ç‚¹
	return distance.keys()
	# å¦‚æœéœ€è¦è¿”å›ç¦»ç»ˆç‚¹çš„æœ€çŸ­è·ç¦»
	return distance[end_node]
```

**Java æ‹“æ‰‘æ’åº BFS æ¨¡æ¿**

```java
List<Node> topologicalSort(List<Node> nodes) {
	// ç»Ÿè®¡æ‰€æœ‰ç‚¹çš„â¼Šåº¦ä¿¡æ¯ï¼Œæ”¾â¼Š hashmap â¾¥
	Map<Node, Integer> indegrees = getIndegrees(nodes);

	// å°†æ‰€æœ‰â¼Šåº¦ä¸º 0 çš„ç‚¹æ”¾åˆ°é˜Ÿåˆ—ä¸­
	Queue<Node> queue = new ArrayDeque<>();
	for (Node node : nodes) {
		if (indegrees.get(node) == 0) {
			queue.offer(node);
		}
	}

	List<Node> topoOrder = new ArrayList<>();
	while (!queue.isEmpty()) {
		Node node = queue.poll();
		topoOrder.add(node);
		for (Node neighbor : node.getNeighbors()) {
			// å…¥åº¦å‡ä¸€
			indegrees.put(neighbor, indegrees.get(neighbor) - 1);
			// å…¥åº¦å‡åˆ°0è¯´æ˜ä¸å†ä¾èµ–ä»»ä½•ç‚¹ï¼Œå¯ä»¥è¢«æ”¾åˆ°é˜Ÿåˆ—ï¼ˆæ‹“æ‰‘åºï¼‰é‡Œäº†
			if (indegrees.get(neighbor) == 0) {
			queue.offer(neighbor);
			}
		}
	}

	// å¦‚æœ queue æ˜¯ç©ºçš„æ—¶å€™ï¼Œå›¾ä¸­è¿˜æœ‰ç‚¹æ²¡æœ‰è¢«æŒ–å‡ºæ¥ï¼Œè¯´æ˜å­˜åœ¨ç¯
	// æœ‰ç¯å°±æ²¡æœ‰æ‹“æ‰‘åº
	if (topoOrder.size() != nodes.size()) {
		return æ²¡æœ‰æ‹“æ‰‘åº;
	}
	return topoOrder;
}

Map<Node, Integer> getIndegrees(List<Node> nodes) {
	Map<Node, Integer> counter = new HashMap<>();
	for (Node node : nodes) {
		counter.put(node, 0);
	}
	for (Node node : nodes) {
		for (Node neighbor : node.getNeighbors()) {
			counter.put(neighbor, counter.get(neighbor) + 1);
		}
	}
	return counter;
}
```

Python
```python
def get_indegrees(nodes):
	counter = {node: 0 for node in nodes}
	for node in nodes:
		for neighbor in node.get_neighbors():
			counter[neighbor] += 1
	return counter

def topological_sort(nodes):
	# ç»Ÿè®¡â¼Šåº¦
	indegrees = get_indegrees(nodes)
	# æ‰€æœ‰â¼Šåº¦ä¸º 0 çš„ç‚¹éƒ½æ”¾åˆ°é˜Ÿåˆ—â¾¥
	queue = collections.deque([
	node
	for node in nodes
	if indegrees[node] == 0
	])
	# â½¤ BFS ç®—æ³•â¼€ä¸ªä¸ªæŠŠç‚¹ä»å›¾â¾¥æŒ–å‡ºæ¥
	topo_order = []
	while queue:
		node = queue.popleft()
		topo_order.append(node)
		for neighbor in node.get_neighbors():
			indegrees[neighbor] -= 1
			if indegrees[neighbor] == 0:
				queue.append(neighbor)
	# åˆ¤æ–­æ˜¯å¦æœ‰å¾ªç¯ä¾èµ–
	if len(topo_order) != len(nodes):
		return æœ‰å¾ªç¯ä¾èµ–(ç¯),æ²¡æœ‰æ‹“æ‰‘åº
	return topo_order
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## æ·±åº¦ä¼˜å…ˆæœç´¢ DFS

### ä½¿ç”¨æ¡ä»¶
- æ‰¾æ»¡â¾œæŸä¸ªæ¡ä»¶çš„æ‰€æœ‰â½…æ¡ˆ (99%)
- â¼†å‰æ ‘ Binary Tree çš„é—®é¢˜ (90%)
- ç»„åˆé—®é¢˜(95%)
  - é—®é¢˜æ¨¡å‹ï¼šæ±‚å‡ºæ‰€æœ‰æ»¡â¾œæ¡ä»¶çš„â€œç»„åˆâ€
  - åˆ¤æ–­æ¡ä»¶ï¼šç»„åˆä¸­çš„å…ƒç´ æ˜¯é¡ºåºâ½†å…³çš„
- æ’åˆ—é—®é¢˜ (95%)
  - é—®é¢˜æ¨¡å‹ï¼šæ±‚å‡ºæ‰€æœ‰æ»¡â¾œæ¡ä»¶çš„â€œæ’åˆ—â€
  - åˆ¤æ–­æ¡ä»¶ï¼šç»„åˆä¸­çš„å…ƒç´ æ˜¯é¡ºåºâ€œç›¸å…³â€çš„ã€‚

### ä¸è¦ç”¨ DFS çš„åœºæ™¯

- è¿é€šå—é—®é¢˜ï¼ˆâ¼€å®šè¦â½¤ BFSï¼Œå¦åˆ™ StackOverflowï¼‰
- æ‹“æ‰‘æ’åºï¼ˆâ¼€å®šè¦â½¤ BFSï¼Œå¦åˆ™ StackOverflowï¼‰
- â¼€åˆ‡ BFS å¯ä»¥è§£å†³çš„é—®é¢˜

### å¤æ‚åº¦
- æ—¶é—´å¤æ‚åº¦ï¼šO(â½…æ¡ˆä¸ªæ•° * æ„é€ æ¯ä¸ªâ½…æ¡ˆçš„æ—¶é—´)
  - æ ‘çš„éå† ï¼š O(n)
  - æ’åˆ—é—®é¢˜ ï¼š O(n! * n)
  - ç»„åˆé—®é¢˜ ï¼š O(2^n * n)


### é¢†æ‰£ä¾‹é¢˜

- LintCode 67.â¼†å‰æ ‘çš„ä¸­åºéå†(éå†æ ‘)
  - https://www.lintcode.com/problem/binary-tree-inorder-traversal/description
- LintCode 652.å› å¼åˆ†è§£(æšä¸¾æ‰€æœ‰æƒ…å†µ)
  - https://www.lintcode.com/problem/factorization/description

### ä»£ç æ¨¡ç‰ˆ

Java

```java
public ReturnType dfs(å‚æ•°åˆ—è¡¨) {
	if (é€’å½’å‡ºâ¼) {
		è®°å½•ç­”æ¡ˆ;
		return;
	}
	for (æ‰€æœ‰çš„æ‹†è§£å¯èƒ½æ€§) {
		ä¿®æ”¹æ‰€æœ‰çš„å‚æ•°
		dfs(å‚æ•°åˆ—è¡¨);
		è¿˜åŸæ‰€æœ‰è¢«ä¿®æ”¹è¿‡çš„å‚æ•°
	}
	return something å¦‚æœéœ€è¦çš„è¯ï¼Œå¾ˆå¤šæ—¶å€™ä¸éœ€è¦ return å€¼é™¤äº†åˆ†æ²»çš„å†™æ³•
}
```

Python

```python
def dfs(å‚æ•°åˆ—è¡¨):
	if é€’å½’å‡ºå£:
		è®°å½•ç­”æ¡ˆ
		return
	for æ‰€æœ‰çš„æ‹†è§£å¯èƒ½æ€§:
	ä¿®æ”¹æ‰€æœ‰çš„å‚æ•°
	dfs(å‚æ•°åˆ—è¡¨)
	è¿˜åŸæ‰€æœ‰è¢«ä¿®æ”¹è¿‡çš„å‚æ•°
	return something å¦‚æœéœ€è¦çš„è¯ï¼Œå¾ˆå¤šæ—¶å€™ä¸éœ€è¦ return å€¼é™¤äº†åˆ†æ²»çš„å†™æ³•
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## åŠ¨æ€è§„åˆ’ Dynamic Programming
### ä½¿ç”¨æ¡ä»¶
- ä½¿ç”¨åœºæ™¯ï¼š
  - æ±‚â½…æ¡ˆæ€»æ•°(90%)
  - æ±‚æœ€å€¼(80%)
  - æ±‚å¯â¾æ€§(80%)
- ä¸é€‚â½¤çš„åœºæ™¯ï¼š
  - æ‰¾æ‰€æœ‰å…·ä½“çš„â½…æ¡ˆï¼ˆå‡†ç¡®ç‡99%ï¼‰
  - è¾“â¼Šæ•°æ®â½†åº(é™¤äº†èƒŒåŒ…é—®é¢˜å¤–ï¼Œå‡†ç¡®ç‡60%~70%)
  - æš´â¼’ç®—æ³•å·²ç»æ˜¯å¤šé¡¹å¼æ—¶é—´å¤æ‚åº¦ï¼ˆå‡†ç¡®ç‡80%ï¼‰
- åŠ¨æ€è§„åˆ’å››è¦ç´ (å¯¹â½é€’å½’çš„å››è¦ç´ )ï¼š
  - çŠ¶æ€ (State) -- é€’å½’çš„å®šä¹‰
  - â½…ç¨‹ (Function) -- é€’å½’çš„æ‹†è§£
  - åˆå§‹åŒ– (Initialization) -- é€’å½’çš„å‡ºâ¼
  - ç­”æ¡ˆ (Answer) -- é€’å½’çš„è°ƒâ½¤

### â¼ç§å¸¸â»…çš„åŠ¨æ€è§„åˆ’ï¼š
- **èƒŒåŒ…å‹**
- ç»™å‡º n ä¸ªç‰©å“åŠå…¶â¼¤â¼©,é—®æ˜¯å¦èƒ½æŒ‘é€‰å‡ºâ¼€äº›ç‰©å“è£…æ»¡â¼¤â¼©ä¸ºmçš„èƒŒåŒ…
- é¢˜â½¬ä¸­é€šå¸¸æœ‰â€œå’Œâ€ä¸â€œå·®â€çš„æ¦‚å¿µï¼Œæ•°å€¼ä¼šè¢«æ”¾åˆ°çŠ¶æ€ä¸­
- é€šå¸¸æ˜¯â¼†ç»´çš„çŠ¶æ€æ•°ç»„ï¼Œå‰ i ä¸ªç»„æˆå’Œä¸º j çŠ¶æ€æ•°ç»„çš„â¼¤â¼©éœ€è¦å¼€ (n + 1) * (m + 1)
- â¼ç§èƒŒåŒ…ç±»å‹ï¼š
- **èƒŒåŒ…å‹**
  - 01èƒŒåŒ…
    - **çŠ¶æ€ state**
      dp[i][j] è¡¨â½°å‰ i ä¸ªæ•°â¾¥æŒ‘è‹¥â¼²ä¸ªæ•°æ˜¯å¦èƒ½ç»„æˆå’Œä¸º j
    - **â½…ç¨‹ function**
      dp[i][j] = dp[i - 1][j] or dp[i - 1][j - A[i - 1]] å¦‚æœ j >= A[i - 1]
      dp[i][j] = dp[i - 1][j] å¦‚æœ j < A[i - 1]
      ç¬¬ i ä¸ªæ•°çš„ä¸‹æ ‡æ˜¯ i - 1ï¼Œæ‰€ä»¥â½¤çš„æ˜¯ A[i - 1] â½½ä¸æ˜¯ A[i]
    - **åˆå§‹åŒ– initialization**
      dp[0][0] = true
      dp[0][1...m] = false
    - **ç­”æ¡ˆ answer**
      ä½¿å¾— dp[n][v], 0 s <= v <= m ä¸º true çš„æœ€â¼¤ v
  - å¤šé‡èƒŒåŒ…
    - çŠ¶æ€ state
      dp[i][j] è¡¨â½°å‰iä¸ªç‰©å“æŒ‘å‡ºâ¼€äº›æ”¾åˆ° j çš„èƒŒåŒ…â¾¥çš„æœ€â¼¤ä»·å€¼å’Œ
    - â½…ç¨‹ function
      dp[i][j] = max(dp[i - 1][j - count * A[i - 1]] + count * V[i- 1])
      å…¶ä¸­ 0 <= count <= j / A[i - 1]
    - åˆå§‹åŒ– initialization
      dp[0][0..m] = 0
    - ç­”æ¡ˆ answer
      dp[n][m]

- **åŒºé—´å‹**
- é¢˜â½¬ä¸­æœ‰ subarray / substring çš„ä¿¡æ¯
  - â¼¤åŒºé—´ä¾èµ–â¼©åŒºé—´
  - â½¤ dp[i][j] è¡¨â½°æ•°ç»„/å­—ç¬¦ä¸²ä¸­ i, j è¿™â¼€æ®µåŒºé—´çš„æœ€ä¼˜å€¼/å¯â¾æ€§/â½…æ¡ˆæ€»æ•°
  - **çŠ¶æ€ state**
   dp[i][j] è¡¨â½°æ•°ç»„/å­—ç¬¦ä¸²ä¸­ i,j è¿™â¼€æ®µåŒºé—´çš„æœ€ä¼˜å€¼/å¯â¾æ€§/â½…æ¡ˆæ€»æ•°
  - â½…ç¨‹ function
  dp[i][j] = max/min/sum/or(dp[i,j ä¹‹å†…æ›´â¼©çš„è‹¥â¼²åŒºé—´])
- **åŒ¹é…å‹**
  - é€šå¸¸ç»™å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²
  - ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åŒ¹é…å€¼ä¾èµ–äºä¸¤ä¸ªå­—ç¬¦ä¸²å‰ç¼€çš„åŒ¹é…å€¼
  - å­—ç¬¦ä¸²â»“åº¦ä¸º n,m åˆ™éœ€è¦å¼€ (n + 1) x (m + 1) çš„çŠ¶æ€æ•°ç»„
  - è¦åˆå§‹åŒ– dp[i][0] ä¸ dp[0][i]
  - é€šå¸¸éƒ½å¯ä»¥â½¤æ»šåŠ¨æ•°ç»„è¿›â¾ç©ºé—´ä¼˜åŒ–
  - çŠ¶æ€ state
  dp[i][j] è¡¨â½°ç¬¬â¼€ä¸ªå­—ç¬¦ä¸²çš„å‰ i ä¸ªå­—ç¬¦ä¸ç¬¬â¼†ä¸ªå­—ç¬¦ä¸²çš„å‰ j ä¸ªå­—ç¬¦æ€ä¹ˆæ ·æ€ä¹ˆæ ·
(max/min/sum/or)

- **åˆ’åˆ†å‹**
  - æ˜¯å‰ç¼€å‹åŠ¨æ€è§„åˆ’çš„â¼€ç§, æœ‰å‰ç¼€çš„æ€æƒ³
  - å¦‚æœæŒ‡å®šäº†è¦åˆ’åˆ†ä¸ºâ¼ä¸ªéƒ¨åˆ†ï¼š
    - dp[i][j] è¡¨â½°å‰iä¸ªæ•°/å­—ç¬¦åˆ’åˆ†ä¸ºjä¸ª éƒ¨åˆ†çš„æœ€ä¼˜å€¼/â½…æ¡ˆæ•°/å¯â¾æ€§
  - å¦‚æœæ²¡æœ‰æŒ‡å®šåˆ’åˆ†ä¸ºâ¼ä¸ªéƒ¨åˆ†:
    - dp[i] è¡¨â½°å‰iä¸ªæ•°/å­—ç¬¦åˆ’åˆ†ä¸ºè‹¥â¼²ä¸ª éƒ¨åˆ†çš„æœ€ä¼˜å€¼/â½…æ¡ˆæ•°/å¯â¾æ€§
  - çŠ¶æ€ state
    - æŒ‡å®šäº†è¦åˆ’åˆ†ä¸ºâ¼ä¸ªéƒ¨åˆ†: dp[i][j] è¡¨â½°å‰iä¸ªæ•°/å­—ç¬¦åˆ’åˆ†ä¸ºjä¸ªéƒ¨åˆ†çš„æœ€ä¼˜å€¼/â½…æ¡ˆæ•°/å¯â¾æ€§
    - æ²¡æœ‰æŒ‡å®šåˆ’åˆ†ä¸ºâ¼ä¸ªéƒ¨åˆ†: dp[i] è¡¨â½°å‰iä¸ªæ•°/å­—ç¬¦åˆ’åˆ†ä¸ºè‹¥â¼²ä¸ªéƒ¨åˆ†çš„æœ€ä¼˜å€¼/â½…æ¡ˆæ•°/å¯â¾æ€§

- **æ¥â»°å‹**
  - é€šå¸¸ä¼šç»™â¼€ä¸ªæ¥â»°è§„åˆ™ï¼Œé—®ä½ æœ€â»“çš„â»°æœ‰å¤šâ»“
  - çŠ¶æ€è¡¨â½°é€šå¸¸ä¸º: dp[i] è¡¨â½°ä»¥åæ ‡ä¸º i çš„å…ƒç´ ç»“å°¾çš„æœ€â»“â»°çš„â»“åº¦
  - â½…ç¨‹é€šå¸¸æ˜¯: dp[i] = max{dp[j] + 1}, j çš„åâ¾¯å¯ä»¥æ¥ä¸Š i
  - LIS çš„â¼†åˆ†åšæ³•é€‰æ‹©æ€§çš„æŒæ¡ï¼Œä½†å¹¶ä¸æ˜¯æ‰€æœ‰çš„æ¥â»°å‹DPéƒ½å¯ä»¥â½¤â¼†åˆ†æ¥ä¼˜åŒ–
  - çŠ¶æ€ state
    - çŠ¶æ€è¡¨â½°é€šå¸¸ä¸º: dp[i] è¡¨â½°ä»¥åæ ‡ä¸º i çš„å…ƒç´ ç»“å°¾çš„æœ€â»“â»°çš„â»“åº¦
  - â½…ç¨‹ function
    - dp[i] = max{dp[j] + 1}, j çš„åâ¾¯å¯ä»¥æ¥ä¸Š i


### å¤æ‚åº¦
- æ—¶é—´å¤æ‚åº¦:
  - O(çŠ¶æ€æ€»æ•° * æ¯ä¸ªçŠ¶æ€çš„å¤„ç†è€—è´¹)
  - ç­‰äºO(çŠ¶æ€æ€»æ•° * å†³ç­–æ•°)
- ç©ºé—´å¤æ‚åº¦ï¼š
  - O(çŠ¶æ€æ€»æ•°) (ä¸ä½¿â½¤æ»šåŠ¨æ•°ç»„ä¼˜åŒ–)
  - O(çŠ¶æ€æ€»æ•° / n)(ä½¿â½¤æ»šåŠ¨æ•°ç»„ä¼˜åŒ–, næ˜¯è¢«æ»šåŠ¨æ‰çš„é‚£â¼€ä¸ªç»´åº¦)

### é¢†æ‰£ä¾‹é¢˜

- LintCode563.èƒŒåŒ…é—®é¢˜V(èƒŒåŒ…å‹):
  - https://www.lintcode.com/problem/backpack-v/description
- LintCode76.æœ€â»“ä¸Šå‡â¼¦åºåˆ—(æ¥â»°å‹):
  - https://www.lintcode.com/problem/longest-increasing-subsequence/description
- LintCode 476.â½¯â¼¦å½’å¹¶V(åŒºé—´å‹):
  - https://www.lintcode.com/problem/stone-game/description
- LintCode 192. é€šé…ç¬¦åŒ¹é… (åŒ¹é…å‹):
  - https://www.lintcode.com/problem/wildcard-matching/description
- LintCode107.å•è¯æ‹†åˆ†(åˆ’åˆ†å‹):
  - https://www.lintcode.com/problem/word-break/description


ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## å † Heap

### ä½¿ç”¨æ¡ä»¶

- æ‰¾æœ€â¼¤å€¼æˆ–è€…æœ€â¼©å€¼(60%)
- æ‰¾ç¬¬ k â¼¤(pop k æ¬¡ å¤æ‚åº¦O(nlogk))(50%)
- è¦æ±‚ logn æ—¶é—´å¯¹æ•°æ®è¿›â¾æ“ä½œ(40%)

### å †ä¸èƒ½è§£å†³çš„é—®é¢˜
- æŸ¥è¯¢â½æŸä¸ªæ•°â¼¤çš„æœ€â¼©å€¼/æœ€æ¥è¿‘çš„å€¼ï¼ˆå¹³è¡¡æ’åºâ¼†å‰æ ‘ Balanced BST æ‰å¯ä»¥è§£å†³ï¼‰
- æ‰¾æŸæ®µåŒºé—´çš„æœ€â¼¤å€¼æœ€â¼©å€¼ï¼ˆçº¿æ®µæ ‘ SegmentTree å¯ä»¥è§£å†³ï¼‰
- O(n)æ‰¾ç¬¬kâ¼¤ (ä½¿â½¤å¿«æ’ä¸­çš„partitionæ“ä½œ)

### é¢†æ‰£ä¾‹é¢˜

- LintCode 1274. æŸ¥æ‰¾å’Œæœ€â¼©çš„Kå¯¹æ•°å­—
  - https://www.lintcode.com/problem/find-k-pairs-with-smallest-sums/description
- LintCode 919. ä¼šè®®å®¤ II
  - https://www.lintcode.com/problem/meeting-rooms-ii/description
- LintCode 1512.é›‡ä½£Kä¸ªâ¼ˆçš„æœ€ä½è´¹â½¤
  - https://www.lintcode.com/problem/minimum-cost-to-hire-k-workers/description


### ä»£ç æ¨¡æ¿

Java å¸¦åˆ é™¤ç‰¹å®šå…ƒç´ åŠŸèƒ½çš„å †

```java
class ValueIndexPair {
	int val, index;
	public ValueIndexPair(int val, int index) {
		this.val = val;
		this.index = index;
	}
}

class Heap {
	private Queue<ValueIndexPair> minheap;
	private Set<Integer> deleteSet;
	public Heap() {
		minheap = new PriorityQueue<>((p1, p2) -> (p1.val - p2.val));
		deleteSet = new HashSet<>();
	}

	public void push(int index, int val) {
		minheap.add(new ValueIndexPair(val, index));
	}

	private void lazyDeletion() {
		while (minheap.size() != 0 && deleteSet.contains(minheap.peek().index)) {
			ValueIndexPair pair = minheap.poll();
			deleteSet.remove(pair.index);
		}
	}

	public ValueIndexPair top() {
		lazyDeletion();
		return minheap.peek();
	}

	public void pop() {
		lazyDeletion();
		minheap.poll();
	}

	public void delete(int index) {
		deleteSet.add(index);
	}

	public boolean isEmpty() {
		return minheap.size() == 0;
	}
}
```

Python
```python
from heapq import heappush, heappop

class Heap:
	def __init__(self):
		self.minheap = []
		self.deleted_set = set()

	def push(self, index, val):
		heappush(self.minheap, (val, index))

	def _lazy_deletion(self):
		while self.minheap and self.minheap[0][1] in self.deleted_set:
		heappop(self.minheap)

	def top(self):
		self._lazy_deletion()
		return self.minheap[0]

	def pop(self):
		self._lazy_deletion()
		heappop(self.minheap)

	def delete(self, index):
		self.deleted_set.add(index)

	def is_empty(self):
		return not bool(self.minheap)
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## å¹¶æŸ¥é›† Union Find

### ä½¿ç”¨æ¡ä»¶

- éœ€è¦æŸ¥è¯¢å›¾çš„è¿é€šçŠ¶å†µçš„é—®é¢˜
- éœ€è¦â½€æŒå¿«é€Ÿåˆå¹¶ä¸¤ä¸ªé›†åˆçš„é—®é¢˜

### å¤æ‚åº¦
- æ—¶é—´å¤æ‚åº¦ union O(1), find O(1)
- ç©ºé—´å¤æ‚åº¦ O(n)


### é¢†æ‰£ä¾‹é¢˜

- LintCode 1014. æ‰“ç –å—
  - https://www.lintcode.com/problem/bricks-falling-when-hit/
- LintCode 1813. æ„é€ â¼†å‰æ ‘
  - https://www.lintcode.com/problem/construct-binary-tree/

### ä»£ç æ¨¡æ¿

Java

```java
class UnionFind {
	private Map<Integer, Integer> father;
	private Map<Integer, Integer> sizeOfSet;
	private int numOfSet = 0;
	public UnionFind() {
		// åˆå§‹åŒ–â½—æŒ‡é’ˆï¼Œé›†åˆâ¼¤â¼©ï¼Œé›†åˆæ•°é‡
		father = new HashMap<Integer, Integer>();
		sizeOfSet = new HashMap<Integer, Integer>();
		numOfSet = 0;
	}

	public void add(int x) {
		// ç‚¹å¦‚æœå·²ç»å‡ºç°ï¼Œæ“ä½œâ½†æ•ˆ
		if (father.containsKey(x)) {
			return;
		}
		// åˆå§‹åŒ–ç‚¹çš„â½—äº²ä¸º ç©ºå¯¹è±¡null
		// åˆå§‹åŒ–è¯¥ç‚¹æ‰€åœ¨é›†åˆâ¼¤â¼©ä¸º 1
		// é›†åˆæ•°é‡å¢åŠ  1
		father.put(x, null);
		sizeOfSet.put(x, 1);
		numOfSet++;
	}

	public void merge(int x, int y) {
		// æ‰¾åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æ ¹
		int rootX = find(x);
		int rootY = find(y);
		// å¦‚æœæ ¹ä¸æ˜¯åŒâ¼€ä¸ªåˆ™è¿æ¥
		if (rootX != rootY) {
			// å°†ä¸€ä¸ªç‚¹çš„æ ¹å˜æˆæ–°çš„æ ¹
			// é›†åˆæ•°é‡å‡å°‘ 1
			// è®¡ç®—æ–°çš„æ ¹æ‰€åœ¨é›†åˆâ¼¤â¼©
			father.put(rootX, rootY);
			numOfSet--;
			sizeOfSet.put(rootY, sizeOfSet.get(rootX) + sizeOfSet.get(rootY));
		}
}

	public int find(int x) {
		// æŒ‡é’ˆ root æŒ‡å‘è¢«æŸ¥æ‰¾çš„ç‚¹ x
		// ä¸æ–­æ‰¾åˆ° root çš„çˆ¶äº²
		// ç›´åˆ° root æŒ‡å‘ x çš„æ ¹èŠ‚ç‚¹
		int root = x;
		while (father.get(root) != null) {
		root = father.get(root);
		}
		// å°†è·¯å¾„ä¸Šæ‰€æœ‰ç‚¹æŒ‡å‘æ ¹èŠ‚ç‚¹ root
		while (x != root) {
			// æš‚å­˜ x åŸæœ¬çš„â½—äº²
			// å°† x æŒ‡å‘æ ¹èŠ‚ç‚¹
			// x æŒ‡é’ˆä¸Šç§»è‡³ x çš„çˆ¶èŠ‚ç‚¹
			int originalFather = father.get(x);
			father.put(x, root);
			x = originalFather;
		}
		return root;
	}

	public boolean isConnected(int x, int y) {
		// ä¸¤ä¸ªèŠ‚ç‚¹è¿é€š ç­‰ä»·äº ä¸¤ä¸ªèŠ‚ç‚¹çš„æ ¹ç›¸åŒ
		return find(x) == find(y);
	}

	public int getNumOfSet() {
		// è·å¾—é›†åˆæ•°é‡
		return numOfSet;
	}

	public int getSizeOfSet(int x) {
		// è·å¾—æŸä¸ªç‚¹æ‰€åœ¨é›†åˆâ¼¤â¼©
		return sizeOfSet.get(find(x));
	}
}

```

Python

```python
class UnionFind:
def __init__(self):
	# åˆå§‹åŒ–â½—æŒ‡é’ˆï¼Œé›†åˆâ¼¤â¼©ï¼Œé›†åˆæ•°é‡
	self.father = {}
	self.size_of_set = {}
	self.num_of_set = 0

def add(self, x):
	# ç‚¹å¦‚æœå·²ç»å‡ºç°ï¼Œæ“ä½œâ½†æ•ˆ
	if x in self.father:
		return
	# åˆå§‹åŒ–ç‚¹çš„â½—äº²ä¸º ç©ºå¯¹è±¡None
	# åˆå§‹åŒ–è¯¥ç‚¹æ‰€åœ¨é›†åˆâ¼¤â¼©ä¸º 1
	# é›†åˆæ•°é‡å¢åŠ  1
	self.father[x] = None
	self.num_of_set += 1
	self.size_of_set[x] = 1

def merge(self, x, y):
	# æ‰¾åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æ ¹
	root_x, root_y = self.find(x), self.find(y)
	# å¦‚æœæ ¹ä¸æ˜¯åŒâ¼€ä¸ªåˆ™è¿æ¥
	if root_x != root_y:
		# å°†â¼€ä¸ªç‚¹çš„æ ¹å˜æˆæ–°çš„æ ¹
		# é›†åˆæ•°é‡å‡å°‘ 1
		# è®¡ç®—æ–°çš„æ ¹æ‰€åœ¨é›†åˆâ¼¤â¼©
		self.father[root_x] = root_y
		self.num_of_set -= 1
		self.size_of_set[root_y] += self.size_of_set[root_x]

def find(self, x):
	# æŒ‡é’ˆ root æŒ‡å‘è¢«æŸ¥æ‰¾çš„ç‚¹ x
	# ä¸æ–­æ‰¾åˆ° root çš„â½—äº²
	# ç›´åˆ° root æŒ‡å‘ x çš„æ ¹èŠ‚ç‚¹
	root = x
	while self.father[root] != None:
		root = self.father[root]
	# å°†è·¯å¾„ä¸Šæ‰€æœ‰ç‚¹æŒ‡å‘æ ¹èŠ‚ç‚¹ root
	while x != root:
		# æš‚å­˜ x åŸæœ¬çš„â½—äº²
		# å°† x æŒ‡å‘æ ¹èŠ‚ç‚¹
		# x æŒ‡é’ˆä¸Šç§»â¾„ x çš„â½—èŠ‚ç‚¹
		original_father = self.father[x]
		self.father[x] = root
		x = original_father
	return root

def is_connected(self, x, y):
	# ä¸¤ä¸ªèŠ‚ç‚¹è¿é€š ç­‰ä»·äº ä¸¤ä¸ªèŠ‚ç‚¹çš„æ ¹ç›¸åŒ
	return self.find(x) == self.find(y)

def get_num_of_set(self):
	# è·å¾—é›†åˆæ•°é‡
	return self.num_of_set

def get_size_of_set(self, x):
	# è·å¾—æŸä¸ªç‚¹æ‰€åœ¨é›†åˆâ¼¤â¼©
	return self.size_of_set[self.find(x)]
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)

## å­—å…¸æ ‘ Trie
### ä½¿ç”¨æ¡ä»¶
- éœ€è¦æŸ¥è¯¢åŒ…å«æŸä¸ªå‰ç¼€çš„å•è¯/å­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨
- å­—ç¬¦çŸ©é˜µä¸­æ‰¾å•è¯çš„é—®é¢˜

### å¤æ‚åº¦
- æ—¶é—´å¤æ‚åº¦ O(L) å¢åˆ æŸ¥æ”¹
- ç©ºé—´å¤æ‚åº¦ O(N * L) N æ˜¯å•è¯æ•°ï¼ŒLæ˜¯å•è¯â»“åº¦

### é¢†æ‰£ä¾‹é¢˜
- LintCode 1221. è¿æ¥è¯
  - https://www.lintcode.com/problem/concatenated-words/
- LintCode 1624. æœ€â¼¤è·ç¦»
  - https://www.lintcode.com/problem/max-distance/
- LintCode 1090. æ˜ å°„é…å¯¹ä¹‹å’Œ
  - https://www.lintcode.com/problem/map-sum-pairs/

### ä»£ç æ¨¡æ¿

Java

```java 
class TrieNode {
	// å„¿å­èŠ‚ç‚¹
	public Map<Character, TrieNode> children;
	// æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹æ˜¯å¦æ˜¯ä¸€ä¸ªå•è¯
	public boolean isWord;
	// æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„å•è¯æ˜¯ä»€ä¹ˆ
	public String word;
	public TrieNode() {
		sons = new HashMap<Character, TrieNode>();
		isWord = false;
		word = null;
	}
}

public class Trie {
	private TrieNode root;
		public Trie() {
		root = new TrieNode();
	}

	public TrieNode getRoot() {
		return root;
	}

	// æ’å…¥å•è¯
	public void insert(String word) {
		TrieNode node = root;
		for (int i = 0; i < word.length(); i++) {
			char letter = word.charAt(i);
			if (!node.sons.containsKey(letter)) {
				node.sons.put(letter, new TrieNode());
			}
			node = node.sons.get(letter);
		}
		node.isWord = true;
		node.word = word;
	}

	// åˆ¤æ–­å•è¯ word æ˜¯ä¸æ˜¯åœ¨å­—å…¸æ ‘ä¸­
	public boolean hasWord(String word) {
		int L = word.length();
		TrieNode node = root;
		for (int i = 0; i < L; i++) {
			char letter = word.charAt(i);
			if (!node.sons.containsKey(letter)) {
				return false;
			}
			node = node.sons.get(letter);
		}
		return node.isWord;
	}

	// åˆ¤æ–­å‰ç¼€ prefix æ˜¯ä¸æ˜¯åœ¨å­—å…¸æ ‘ä¸­
	public boolean hasPrefix(String prefix) {
		int L = prefix.length();
		TrieNode node = root;
		for (int i = 0; i < L; i++) {
			char letter = prefix.charAt(i);
			if (!node.sons.containsKey(letter)) {
				return false;
			}
			node = node.sons.get(letter);
		}
		return true;
	}
}
```

ğŸ‘† [<b>BACK to Table of Contents</b> -->](#ç›®å½•-menu)


<br>
<p align="center">
<img align="center" src="FLAG.jpg"><br>
<br>Feel free to ask any questions, open a PR if you feel something can be done differently!</p>
<h2 align="center">ğŸŒŸStar this repositoryğŸŒŸ</h2>
<p align="center">Created by <a href="https://github.com/Charmve">Charmve</a> & <a href="https://github.com/MaiweiAI">maiwei.ai</a> Community | All Rights Received by <a href="https://github.com/MaiweiAI">maiwei.ai</a></p>

<br>
