# ⾯试常考算法模板 Cheat Sheet V4.1

版权归属：迈微信息科技（苏州）有限公司

<br>



## ⼆分法 Binary Search

### 使⽤条件

1. 排序数组 (30-40%是⼆分)
2. 当⾯试官要求你找⼀个⽐ O(n) 更⼩的时间复杂度算法的时候(99%)
3. 找到数组中的⼀个分割位置，使得左半部分满⾜某个条件，右半部分不满⾜(100%)
4. 找到⼀个最⼤/最⼩的值使得某个条件被满⾜(90%)

### 复杂度
- 时间复杂度：O(logn)
- 空间复杂度：O(1)

### 领扣例题
- LintCode 14. ⼆分查找(在排序的数据集上进⾏⼆分)
  - https://www.lintcode.com/problem/first-position-of-target/description
- LintCode 460. 在排序数组中找最接近的K个数 (在未排序的数据集上进⾏⼆分)
  - https://www.lintcode.com/problem/find-k-closest-elements/description
- LintCode 437. 书籍复印(在答案集上进⾏⼆分 )
  - https://www.lintcode.com/problem/copy-books/description

### 代码模版

Java

```java
int binarySearch(int[] nums, int target) {
  // corner case 处理
  if (nums == null || nums.length == 0) {
    return -1;
  }

  int start = 0, end = nums.length - 1;

  // 要点1: start + 1 < end
  while (start + 1 < end) {
    // 要点2：start + (end - start) / 2
    int mid = start + (end - start) / 2;
    // 要点3：=, <, > 分开讨论，mid 不 +1 也不 -1
    if (nums[mid] == target) {
      return mid;
     } else if (nums[mid] < target) {
      start = mid;
     } else {
      end = mid;
     }
   }

   // 要点4: 循环结束后，单独处理start和end
   if (nums[start] == target) {
    return start;
   }
   if (nums[end] == target) {
    return end;
   }
    return -1;
}
```


Python

```python
def binary_search(self, nums, target):
	# corner case 处理
	# 这⾥等价于 nums is None or len(nums) == 0
	if not nums:
		return -1

	start, end = 0, len(nums) - 1

	# 用 start + 1 < end 而不是 start < end 的⽬的是为了避免死循环
	# 在 first position of target 的情况下不会出现死循环
	# 但是在 last position of target 的情况下会出现死循环
	# 样例：nums=[1，1] target = 1
	# 为了统一模板，我们就都采用 start + 1 < end，就保证不会出现死循环
	while start + 1 < end:
		# python 没有 overflow 的问题，直接 // 2 就可以了
		# java和C++ 最好写成 mid = start + (end - start) / 2
		# 防止在 start = 2^31 - 1, end = 2^31 - 1 的情况下出现加法 overflow
		mid = (start + end) // 2
		# > , =, < 的逻辑先分开写，然后在看看 = 的情况是否能合并到其他分支里
		if nums[mid] < target:
			start = mid
		elif nums[mid] == target:
			end = mid
		else:
			end = mid

	# 因为上⾯的循环退出条件是 start + 1 < end
	# 因此这⾥循环结束的时候，start 和 end 的关系是相邻关系（1和2，3和4这种）
	# 因此需要再单独判断 start 和 end 这两个数谁是我们要的答案
	# 如果是找 first position of target 就先看 start，否则就先看 end
	if nums[start] == target:
		return start
	if nums[end] == target:
		return end
	return -1
```

## 双指针 Two Pointers
### 使⽤条件

- 滑动窗⼝ (90%)
- 时间复杂度要求 O(n) (80%是双指针)
- 要求原地操作，只可以使⽤交换，不能使⽤额外空间 (80%)
- 有⼦数组 subarray /⼦字符串 substring 的关键词 (50%)
- 有回⽂ Palindrome 关键词(50%)

### 复杂度

- 时间复杂度：O(n)
  - 时间复杂度与最内层循环主体的执⾏次数有关
  - 与有多少重循环⽆关
- 空间复杂度：O(1)
  - 只需要分配两个指针的额外内存

### 领扣例题
- LintCode 1879. 两数之和VII(同向双指针)
  - https://www.lintcode.com/problem/two-sum-vii/description
- LintCode1712.和相同的⼆元⼦数组(相向双指针)
  - https://www.lintcode.com/problem/binary-subarrays-with-sum/description
- LintCode627. 最⻓回⽂串 (背向双指针)
  - https://www.lintcode.com/problem/longest-palindrome/description
- LintCode 64: 合并有序数组
  - https://www.lintcode.com/problem/merge-sorted-array


### 代码模版

Java
```java
// 相向双指针(patition in quicksort)
public void patition(int[] A, int start, int end) {
	if (start >= end) {
		return;
	}
	int left = start, right = end;
	// key point 1: pivot is the value, not the index
	int pivot = A[(start + end) / 2];
	// key point 2: every time you compare left & right, it should be
	// left <= right not left < right
	while (left <= right) {
		while (left <= right && A[left] < pivot) {
			left++;
		}
		while (left <= right && A[right] > pivot) {
			right--;
		}
		if (left <= right) {
			int temp = A[left];
			A[left] = A[right];
			A[right] = temp;
			left++;
			right--;
		}
	}
}

// 背向双指针
left = position;
right = position + 1;
while (left >= 0 && right < length) {
	if (可以停下来了) {
		break;
	}
	left--;
	right++;
}

// 同向双指针
int j = 0;
for (int i = 0; i < n; i++) {
	// 不满⾜则循环到满⾜搭配为⽌
	while (j < n && i 到 j之间不满足条件) {
		j += 1;
	}
	if (i 到 j之间满足条件) {
		处理i，j这次搭配
	}
}

// 合并双指针
ArrayList<Integer> merge(ArrayList<Integer> list1, ArrayList<Integer> list2) {
	// 需要 new 一个新的 list，而不是在 list1 或者 list2 上直接改动
	ArrayList<Integer> newList = new ArrayList<Integer>();

	int i = 0, j = 0;
	while (i < list1.size() && j < list2.size()) {
		if (list1.get(i) < list2.get(j)) {
			newList.add(list1.get(i));
			i++;
		} else {
			newList.add(list2.get(j));
			j++;
		}
	}

	// 合并上下的数到 newList 里
	// 无需用 if (i < list1.size())，直接 while 即可
	while (i < list1.size()) {
		newList.add(list1.get(i));
		i++;
	}
	while (j < list2.size()) {
		newList.add(list2.get(j);
		j++;
	}

	return newList;
}
```

Python
```python
# 相向双指针(patition in quicksort)
def patition(self, A, start, end):
	if start >= end:
		return
	left, right = start, end
	# key point 1: pivot is the value, not the index
	pivot = A[(start + end) // 2];
	# key point 2: every time you compare left & right, it should be
	# left <= right not left < right
	while left <= right:
		while left <= right and A[left] < pivot:
			left += 1
		while left <= right and A[right] > pivot:
			right -= 1
		if left <= right:
			A[left], A[right] = A[right], A[left]
			left += 1
			right -= 1

	# 背向双指针
	left = position
	right = position + 1
	while left >= 0 and right < len(s):
		if left 和 right 可以停下来了:
			break
		left -= 1
		right += 1

	# 同向双指针
	j = 0
	for i in range(n):
	# 不满⾜则循环到满足搭配为止
	while j < n and i到j之间不满⾜条件:
		j += 1
	if i到j之间满⾜条件:
		处理i到j这段区间

	# 合并双指针
	def merge(list1, list2):
	new_list = []
	i, j = 0, 0

	# 合并的过程只能操作 i, j 的移动，不要去⽤ list1.pop(0) 之类的操作
	# 因为 pop(0) 是 O(n) 的时间复杂度
	while i < len(list1) and j < len(list2):
		if list1[i] < list2[j]:
			new_list.append(list1[i])
			i += 1
		else:
			new_list.append(list2[j])
			j += 1

	# 合并剩下的数到 new_list 里
	# 不要⽤ new_list.extend(list1[i:]) 之类的方法
	# 因为 list1[i:] 会产生额外空间耗费
	while i < len(list1):
		new_list.append(list1[i])
		i += 1
	while j < len(list2):
		new_list.append(list2[j])
		j += 1

	return new_list
```

## 排序算法 Sorting
### 使⽤条件

### 复杂度

- 时间复杂度：
  - 快速排序(期望复杂度) ： O(nlogn)
  - 归并排序(最坏复杂度) ： O(nlogn)
- 空间复杂度：
  - 快速排序 ： O(1)
  - 归并排序 ： O(n)

### 领扣例题
- LintCode 463. 整数排序
  - https://www.lintcode.com/problem/sort-integers/description
- LintCode 464. 整数排序 II
  - https://www.lintcode.com/problem/sort-integers-ii/description

### 代码模板

Java
```java



```
















