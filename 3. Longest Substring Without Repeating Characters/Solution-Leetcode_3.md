## 题目解析 ——双指针 Two Pointer

这道题的目标是找出最长子串，并且该子串必须不包含重复字符，而且这个子串必须是原字符串中连续的一部分（见示例3中的解释说明）。

拿到题目时先不要心急想什么骚操作，我们先从最普通的操作开始把题目解出来，然后再来看如何优化。

接下来，我们画图分析一下，先随便弄一个长相普通的字符串：`frankissohandsome`，我们要从中找出我们想要的子串，那少不了需要遍历，我们设置两个变量`from`，`to`，分别存储寻找的目标子串在原字符串中的首尾位置。

首先，`from`和`to`的初始值都为0（String的序号从0开始），子串长度`length = 1`，最大子串长度`maxLength = 1`。

![fig 1](https://img2018.cnblogs.com/blog/1043143/201903/1043143-20190304193321192-1969993736.png)

然后，我们将`to`的指向往后移动，并判断新遍历的字符是否已经存在于子串中，如果不存在，则将其加入子串中，并将`length`进行自增。

![fig 2](https://img2018.cnblogs.com/blog/1043143/201903/1043143-20190304193330324-1644427481.png)

直到找到一个已存在于子串中的字符，或者`to`到达字符串的末尾。这里，我们找到了一个重复的`s`，序号为`7`，此时的子串为`frankis`，将此时的子串长度与最大子串长度相比较（目前为`0`），如果比最大子串长度大，则将最大子串长度设置为当前子串长度`7`。

![fig 3](https://img2018.cnblogs.com/blog/1043143/201903/1043143-20190304193401397-1670379928.png)

接下来，我们继续寻找符合条件的子串，这里比较关键的一点是下一个子串的起始位置，这里我们将`from`直接跳到了序号为`7`的位置，因为包含`ss`的子串显然都不能满足要求。

![fig 4](https://img2018.cnblogs.com/blog/1043143/201903/1043143-20190304193347300-674023525.png)

然后我们依照之前的方法，找到第二个候选的子串`sohand`，长度为`6`，比目前的最大子串长度小，所以不是目标子串。

![fig 5](https://img2018.cnblogs.com/blog/1043143/201903/1043143-20190304193411328-515395829.png)

接着继续寻找，找到另一个候选子串`ohands`，长度小于最大子串长度，不是我们的目标子串。

![fig 6](https://img2018.cnblogs.com/blog/1043143/201903/1043143-20190304193420895-1291844617.png)

继续寻找。

![fig 7](https://img2018.cnblogs.com/blog/1043143/201903/1043143-20190304193428964-653248475.png)

`to`到达了字符串末尾，找到另一个候选子串`handsome`，长度大于最大子串长度，这就是我们的目标子串。

![fig 8](https://img2018.cnblogs.com/blog/1043143/201903/1043143-20190304193437232-1039982423.png)

于是我们的最大子串长度就轻松加愉快的找到了。接下来的事情就是把上面的思路转化成代码。

这里只需要注意一下`from`的跳转即可，每次跳转的序号为`to`指向的字符在子串中出现的`位置 + 1`。
